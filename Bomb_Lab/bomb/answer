首先声明下每个人的答案是不一样的，
1.Border relations with Canada have never been better.
首先看到strings_not_equal，会想到这是比较字符串，
后面test和je表明不相等就会爆炸，也就自然联想到字符串肯定出现在前面，
因此关键就是查看那个字符串$0x402400，想到这一步基本就没什么问题了

2.1 2 4 8 16 32
首先还是一眼看到read_six_numbers，表明是要输入6个数字，
然后调用此函数的前一步是在开辟栈，也就会想到栈里放的就是那6个数字，
你要做的就是把整个phase_2翻译成c语言，这样方便观察，
之后一眼就会看出第一个数是1,中间是一个循环，其中包含另外5个你要找的数
这题的关键是要知道%rsp-0x28是在开内存，要区分是在寄存器的地址上加上偏移量还是在寄存器内的值上加一个数

3.0 207 或 1 311 等等
第一步先要找输入，一定在调用sscanf前，所以0x4025cf很可疑，查一下，得知要输入两个数字
然后大概翻译下整个phase_3,会发现主体结构是switch，这是一个关键点
接着可以知道第一个数在0-7之间
下一步就是根据jmpq   *0x402470(,%rax,8)这句来建立jump table
这题的核心就是看你是否理解了switch

4.0 0 等等
第一步找输入，看下0x4025cf，知输入为两个数字
然后可以看到要调用fun4,这里先跳过之后可看到第二个数为0,且fun4返回值为0
所以第一个参数就要在fun4中找，而这题就特殊在fun4是个递归函数，这里我网上的答案基本都看了下，要点就是把该函数翻译出来，没别的办法，然而网上翻译的要么是错的要么就没翻译，猜的答案。

5.yonevg
先大致看一遍，可知输入是6个字符，然后查下特殊的地址，一个0x4024b，一个0x40245e
发现前一个是一堆乱七八糟的字符，即一个字符数组
而后面的是flyers，刚好就是6个，然而肯定没这么简单
看中间的循环可发现是把我们输入的字符的低4位地址拿出来作为偏移量加在之前说的那个字符数组上来得到一个别的字符
那这个别的字符是什么呢？其实他就是flyers，因为后面callq的那个string_not_equal
总结下，就是你输入的6个字符的低4位地址作为偏移量在那个字符数组里对应的6个字符恰好是flyers时就是答案了

6.4 3 2 1 6 5
这题代码好多，我实在不想看了，就网上看了下答案，大概就是你输入的6个数字作为索引来排序一个链表中的数字，使他们降序











